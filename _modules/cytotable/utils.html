
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cytotable.utils &#8212; CytoTable v0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="https://unpkg.com/mermaid@10.2.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for cytotable.utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions for CytoTable</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span> <span class="nn">duckdb</span>
<span class="kn">import</span> <span class="nn">parsl</span>
<span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="kn">from</span> <span class="nn">cloudpathlib</span> <span class="kn">import</span> <span class="n">AnyPath</span><span class="p">,</span> <span class="n">CloudPath</span>
<span class="kn">from</span> <span class="nn">cloudpathlib.exceptions</span> <span class="kn">import</span> <span class="n">InvalidPrefixError</span>
<span class="kn">from</span> <span class="nn">parsl.app.app</span> <span class="kn">import</span> <span class="n">AppBase</span>
<span class="kn">from</span> <span class="nn">parsl.config</span> <span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="nn">parsl.errors</span> <span class="kn">import</span> <span class="n">NoDataFlowKernelError</span>
<span class="kn">from</span> <span class="nn">parsl.executors</span> <span class="kn">import</span> <span class="n">HighThroughputExecutor</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># reference the original init</span>
<span class="n">original_init</span> <span class="o">=</span> <span class="n">AppBase</span><span class="o">.</span><span class="fm">__init__</span>


<div class="viewcode-block" id="Parsl_AppBase_init_for_docs"><a class="viewcode-back" href="../../python-api.html#cytotable.utils.Parsl_AppBase_init_for_docs">[docs]</a><span class="k">def</span> <span class="nf">Parsl_AppBase_init_for_docs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function to extend Parsl.app.app.AppBase with</span>
<span class="sd">    docstring from decorated functions rather than</span>
<span class="sd">    the decorators from Parsl. Used for</span>
<span class="sd">    Sphinx documentation purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># add function doc as the app doc</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span></div>


<span class="c1"># set the AppBase to the new init for the docstring.</span>
<span class="n">AppBase</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">Parsl_AppBase_init_for_docs</span>


<div class="viewcode-block" id="_parsl_loaded"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._parsl_loaded">[docs]</a><span class="k">def</span> <span class="nf">_parsl_loaded</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether Parsl configuration has already been loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># try to reference Parsl dataflowkernel</span>
        <span class="n">parsl</span><span class="o">.</span><span class="n">dfk</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">NoDataFlowKernelError</span><span class="p">:</span>
        <span class="c1"># if we detect a Parsl NoDataFlowKernelError</span>
        <span class="c1"># return false to indicate parsl config has not yet been loaded.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># otherwise we indicate parsl config has already been loaded</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="_default_parsl_config"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._default_parsl_config">[docs]</a><span class="k">def</span> <span class="nf">_default_parsl_config</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a default Parsl configuration for use with CytoTable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Config</span><span class="p">(</span>
        <span class="n">executors</span><span class="o">=</span><span class="p">[</span>
            <span class="n">HighThroughputExecutor</span><span class="p">(</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;htex_default_for_cytotable&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span></div>


<span class="c1"># custom sort for resulting columns</span>
<div class="viewcode-block" id="_column_sort"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._column_sort">[docs]</a><span class="k">def</span> <span class="nf">_column_sort</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A custom sort for column values as a list.</span>
<span class="sd">    To be used with sorted and Pyarrow tables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># lowercase str which will be used for comparisons</span>
    <span class="c1"># to avoid any capitalization challenges</span>
    <span class="n">value_lower</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># first sorted values (by list index)</span>
    <span class="n">sort_first</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;tablenumber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_tablenumber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;imagenumber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_imagenumber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;objectnumber&quot;</span><span class="p">,</span>
        <span class="s2">&quot;object_number&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># middle sort value</span>
    <span class="n">sort_middle</span> <span class="o">=</span> <span class="s2">&quot;metadata&quot;</span>

    <span class="c1"># sorted last (by list order enumeration)</span>
    <span class="n">sort_later</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;image&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cytoplasm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cells&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nuclei&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># if value is in the sort_first list</span>
    <span class="c1"># return the index from that list</span>
    <span class="k">if</span> <span class="n">value_lower</span> <span class="ow">in</span> <span class="n">sort_first</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sort_first</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value_lower</span><span class="p">)</span>

    <span class="c1"># if sort_middle is anywhere in value return</span>
    <span class="c1"># next index value after sort_first values</span>
    <span class="k">if</span> <span class="n">sort_middle</span> <span class="ow">in</span> <span class="n">value_lower</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">sort_first</span><span class="p">)</span>

    <span class="c1"># if any sort_later are found as the first part of value</span>
    <span class="c1"># return enumerated index of sort_later value (starting from</span>
    <span class="c1"># relative len based on the above conditionals and lists)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">value_lower</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sort_later</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sort_later</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sort_first</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value_lower</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_k</span>

    <span class="c1"># else we return the total length of all sort values</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">sort_first</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sort_later</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="_duckdb_reader"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._duckdb_reader">[docs]</a><span class="k">def</span> <span class="nf">_duckdb_reader</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">duckdb</span><span class="o">.</span><span class="n">DuckDBPyConnection</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a DuckDB connection with the</span>
<span class="sd">    sqlite_scanner installed and loaded.</span>

<span class="sd">    Note: using this function assumes implementation will</span>
<span class="sd">    close the subsequently created DuckDB connection using</span>
<span class="sd">    `_duckdb_reader().close()` or using a context manager,</span>
<span class="sd">    for ex., using: `with _duckdb_reader() as ddb_reader:`</span>

<span class="sd">    Returns:</span>
<span class="sd">        duckdb.DuckDBPyConnection</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">duckdb</span>

    <span class="kn">from</span> <span class="nn">cytotable.constants</span> <span class="kn">import</span> <span class="n">MAX_THREADS</span>

    <span class="k">return</span> <span class="n">duckdb</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
        <span class="c1"># note: we use an f-string here to</span>
        <span class="c1"># dynamically configure threads as appropriate</span>
        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        /* Install and load sqlite plugin for duckdb */</span>
<span class="s2">        INSTALL sqlite_scanner;</span>
<span class="s2">        LOAD sqlite_scanner;</span>

<span class="s2">        /* Install httpfs plugin to avoid error</span>
<span class="s2">        https://github.com/duckdb/duckdb/issues/3243 */</span>
<span class="s2">        INSTALL httpfs;</span>

<span class="s2">        /*</span>
<span class="s2">        Set threads available to duckdb</span>
<span class="s2">        See the following for more information:</span>
<span class="s2">        https://duckdb.org/docs/sql/pragmas#memory_limit-threads</span>
<span class="s2">        */</span>
<span class="s2">        PRAGMA threads=</span><span class="si">{</span><span class="n">MAX_THREADS</span><span class="si">}</span><span class="s2">;</span>

<span class="s2">        /*</span>
<span class="s2">        Allow unordered results for performance increase possibilities</span>
<span class="s2">        See the following for more information:</span>
<span class="s2">        https://duckdb.org/docs/sql/configuration#configuration-reference</span>
<span class="s2">        */</span>
<span class="s2">        PRAGMA preserve_insertion_order=FALSE;</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="_sqlite_mixed_type_query_to_parquet"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._sqlite_mixed_type_query_to_parquet">[docs]</a><span class="k">def</span> <span class="nf">_sqlite_mixed_type_query_to_parquet</span><span class="p">(</span>
    <span class="n">source_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">table_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">page_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">pageset</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
    <span class="n">sort_output</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs SQLite table data extraction where one or many</span>
<span class="sd">    columns include data values of potentially mismatched type</span>
<span class="sd">    such that the data may be exported to Arrow for later use.</span>

<span class="sd">    Args:</span>
<span class="sd">        source_path: str:</span>
<span class="sd">            A str which is a path to a SQLite database file.</span>
<span class="sd">        table_name: str:</span>
<span class="sd">            The name of the table being queried.</span>
<span class="sd">        page_key: str:</span>
<span class="sd">            The column name to be used to identify pagination chunks.</span>
<span class="sd">        pageset: Tuple[int, int]:</span>
<span class="sd">            The range for values used for paginating data from source.</span>
<span class="sd">        sort_output: bool</span>
<span class="sd">            Specifies whether to sort cytotable output or not.</span>
<span class="sd">        add_cytotable_meta: bool, default=False:</span>
<span class="sd">            Whether to add CytoTable metadata fields or not</span>

<span class="sd">    Returns:</span>
<span class="sd">        pyarrow.Table:</span>
<span class="sd">           The resulting arrow table for the data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sqlite3</span>

    <span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>

    <span class="kn">from</span> <span class="nn">cytotable.constants</span> <span class="kn">import</span> <span class="n">SQLITE_AFFINITY_DATA_TYPE_SYNONYMS</span>
    <span class="kn">from</span> <span class="nn">cytotable.exceptions</span> <span class="kn">import</span> <span class="n">DatatypeException</span>

    <span class="c1"># open sqlite3 connection</span>
    <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">source_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

        <span class="c1"># Gather table column details including datatype.</span>
        <span class="c1"># Note: uses SQLite pragma for table information.</span>
        <span class="c1"># See the following for more information:</span>
        <span class="c1"># https://sqlite.org/pragma.html#pragma_table_info</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SELECT :table_name as table_name,</span>
<span class="sd">                    name as column_name,</span>
<span class="sd">                    type as column_type</span>
<span class="sd">            FROM pragma_table_info(:table_name)</span>
<span class="sd">            /* explicit column ordering by &#39;cid&#39; */</span>
<span class="sd">            ORDER BY cid ASC;</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">&quot;table_name&quot;</span><span class="p">:</span> <span class="n">table_name</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># gather column metadata details as list of dictionaries</span>
        <span class="n">column_info</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">],</span> <span class="n">row</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">def</span> <span class="nf">_sqlite_affinity_data_type_lookup</span><span class="p">(</span><span class="n">col_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># seek the translated type from SQLITE_AFFINITY_DATA_TYPE_SYNONYMS</span>
            <span class="n">translated_type</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">key</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">SQLITE_AFFINITY_DATA_TYPE_SYNONYMS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">col_type</span> <span class="ow">in</span> <span class="n">values</span>
            <span class="p">]</span>

            <span class="c1"># if we&#39;re unable to find a synonym for the type, raise an error</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">translated_type</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DatatypeException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unable to find SQLite data type synonym for </span><span class="si">{</span><span class="n">col_type</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># return the translated type for use in SQLite</span>
            <span class="k">return</span> <span class="n">translated_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># create cases for mixed-type handling in each column discovered above</span>
        <span class="n">query_parts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            CASE</span>
<span class="s2">                /* when the storage class type doesn&#39;t match the column, return nulltype */</span>
<span class="s2">                WHEN typeof(</span><span class="si">{</span><span class="n">col</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">) !=</span>
<span class="s2">                &#39;</span><span class="si">{</span><span class="n">_sqlite_affinity_data_type_lookup</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="s1">&#39;column_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span><span class="si">}</span><span class="s2">&#39; THEN NULL</span>
<span class="s2">                /* else, return the normal value */</span>
<span class="s2">                ELSE </span><span class="si">{</span><span class="n">col</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="si">}</span>
<span class="s2">            END AS </span><span class="si">{</span><span class="n">col</span><span class="p">[</span><span class="s1">&#39;column_name&#39;</span><span class="p">]</span><span class="si">}</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_info</span>
        <span class="p">]</span>

        <span class="c1"># perform the select using the cases built above and using chunksize + offset</span>
        <span class="n">sql_stmt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT</span>
<span class="s2">                </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">query_parts</span><span class="p">)</span><span class="si">}</span>
<span class="s2">            FROM </span><span class="si">{</span><span class="n">table_name</span><span class="si">}</span>
<span class="s2">            WHERE </span><span class="si">{</span><span class="n">page_key</span><span class="si">}</span><span class="s2"> BETWEEN </span><span class="si">{</span><span class="n">pageset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> AND </span><span class="si">{</span><span class="n">pageset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span>
<span class="s2">            </span><span class="si">{</span><span class="s2">&quot;ORDER BY &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">page_key</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">sort_output</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="si">}</span><span class="s2">;</span>
<span class="s2">            &quot;&quot;&quot;</span>

        <span class="c1"># execute the sql stmt</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql_stmt</span><span class="p">)</span>
        <span class="c1"># collect the results and include the column name with values</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">],</span> <span class="n">row</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="c1"># close the sqlite3 cursor</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># close the sqlite3 connection</span>
    <span class="c1"># note: context manager does not automatically close the connection</span>
    <span class="c1"># as per notes found under:</span>
    <span class="c1"># https://docs.python.org/3/library/sqlite3.html#sqlite3-connection-context-manager</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># return arrow table with results</span>
    <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_pylist</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>


<div class="viewcode-block" id="_cache_cloudpath_to_local"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._cache_cloudpath_to_local">[docs]</a><span class="k">def</span> <span class="nf">_cache_cloudpath_to_local</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">AnyPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a cloudpath and uses cache to convert to a local copy</span>
<span class="sd">    for use in scenarios where remote work is not possible (sqlite).</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Union[str, AnyPath]</span>
<span class="sd">            A filepath which will be checked and potentially</span>
<span class="sd">            converted to a local filepath.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pathlib.Path</span>
<span class="sd">            A local pathlib.Path to cached version of cloudpath file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that the path is a file (caching won&#39;t work with a dir)</span>
    <span class="c1"># and check that the file is of sqlite type</span>
    <span class="c1"># (other file types will be handled remotely in cloud)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">CloudPath</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">path</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">path</span><span class="o">.</span><span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.sqlite&quot;</span>
    <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># update the path to be the local filepath for reference in CytoTable ops</span>
            <span class="c1"># note: incurs a data read which will trigger caching of the file</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">fspath</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">InvalidPrefixError</span><span class="p">:</span>
            <span class="c1"># share information about not finding a cloud path</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Did not detect a cloud path based on prefix. Defaulting to use local path operations.&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">path</span></div>


<div class="viewcode-block" id="_arrow_type_cast_if_specified"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._arrow_type_cast_if_specified">[docs]</a><span class="k">def</span> <span class="nf">_arrow_type_cast_if_specified</span><span class="p">(</span>
    <span class="n">column</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">data_type_cast_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts to cast data types for an PyArrow field using provided a data_type_cast_map.</span>

<span class="sd">    Args:</span>
<span class="sd">        column: Dict[str, str]:</span>
<span class="sd">            Dictionary which includes a column idx, name, and dtype</span>
<span class="sd">        data_type_cast_map: Dict[str, str]</span>
<span class="sd">            A dictionary mapping data type groups to specific types.</span>
<span class="sd">            Roughly includes Arrow data types language from:</span>
<span class="sd">            https://arrow.apache.org/docs/python/api/datatypes.html</span>
<span class="sd">            Example: {&quot;float&quot;: &quot;float32&quot;}</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict[str, str]</span>
<span class="sd">            A potentially data type updated dictionary of column information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">cytotable.constants</span> <span class="kn">import</span> <span class="n">DDB_DATA_TYPE_SYNONYMS</span>

    <span class="c1"># for casting to new float type</span>
    <span class="k">if</span> <span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="n">data_type_cast_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">column</span><span class="p">[</span><span class="s2">&quot;column_dtype&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;REAL&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DOUBLE&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;column_id&quot;</span><span class="p">:</span> <span class="n">column</span><span class="p">[</span><span class="s2">&quot;column_id&quot;</span><span class="p">],</span>
            <span class="s2">&quot;column_name&quot;</span><span class="p">:</span> <span class="n">column</span><span class="p">[</span><span class="s2">&quot;column_name&quot;</span><span class="p">],</span>
            <span class="s2">&quot;column_dtype&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">key</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">DDB_DATA_TYPE_SYNONYMS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">data_type_cast_map</span><span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">value</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="c1"># for casting to new int type</span>
    <span class="k">elif</span> <span class="s2">&quot;integer&quot;</span> <span class="ow">in</span> <span class="n">data_type_cast_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">column</span><span class="p">[</span><span class="s2">&quot;column_dtype&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;TINYINT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SMALLINT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;INTEGER&quot;</span><span class="p">,</span>
        <span class="s2">&quot;BIGINT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HUGEINT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;UTINYINT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;USMALLINT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;UINTEGER&quot;</span><span class="p">,</span>
        <span class="s2">&quot;UBIGINT&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;column_id&quot;</span><span class="p">:</span> <span class="n">column</span><span class="p">[</span><span class="s2">&quot;column_id&quot;</span><span class="p">],</span>
            <span class="s2">&quot;column_name&quot;</span><span class="p">:</span> <span class="n">column</span><span class="p">[</span><span class="s2">&quot;column_name&quot;</span><span class="p">],</span>
            <span class="s2">&quot;column_dtype&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">key</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">DDB_DATA_TYPE_SYNONYMS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">data_type_cast_map</span><span class="p">[</span><span class="s2">&quot;integer&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">value</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="c1"># else we retain the existing data field type</span>
    <span class="k">return</span> <span class="n">column</span></div>


<div class="viewcode-block" id="_expand_path"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._expand_path">[docs]</a><span class="k">def</span> <span class="nf">_expand_path</span><span class="p">(</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">AnyPath</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">AnyPath</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expands &quot;~&quot; user directory references with the user&#39;s home directory, and expands variable references with values from the environment. After user/variable expansion, the path is resolved and an absolute path is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Union[str, pathlib.Path, CloudPath]:</span>
<span class="sd">            Path to expand.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[pathlib.Path, Any]</span>
<span class="sd">            A local pathlib.Path or Cloudpathlib.AnyPath type path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">pathlib</span>

    <span class="kn">from</span> <span class="nn">cloudpathlib</span> <span class="kn">import</span> <span class="n">AnyPath</span>

    <span class="c1"># expand environment variables and resolve the path as absolute</span>
    <span class="n">modifed_path</span> <span class="o">=</span> <span class="n">AnyPath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

    <span class="c1"># note: we use pathlib.Path here to help expand local paths (~, etc)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modifed_path</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
        <span class="n">modifed_path</span> <span class="o">=</span> <span class="n">modifed_path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">modifed_path</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span></div>


<div class="viewcode-block" id="_get_cytotable_version"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._get_cytotable_version">[docs]</a><span class="k">def</span> <span class="nf">_get_cytotable_version</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Seeks the current version of CytoTable using either pkg_resources</span>
<span class="sd">    or dunamai to determine the current version being used.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str</span>
<span class="sd">            A string representing the version of CytoTable currently being used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># attempt to gather the development version from dunamai</span>
        <span class="c1"># for scenarios where cytotable from source is used.</span>
        <span class="kn">import</span> <span class="nn">dunamai</span>

        <span class="k">return</span> <span class="n">dunamai</span><span class="o">.</span><span class="n">Version</span><span class="o">.</span><span class="n">from_any_vcs</span><span class="p">()</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ModuleNotFoundError</span><span class="p">):</span>
        <span class="c1"># else grab a static version from __init__.py</span>
        <span class="c1"># for scenarios where the built/packaged cytotable is used.</span>
        <span class="kn">import</span> <span class="nn">cytotable</span>

        <span class="k">return</span> <span class="n">cytotable</span><span class="o">.</span><span class="n">__version__</span></div>


<div class="viewcode-block" id="_write_parquet_table_with_metadata"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._write_parquet_table_with_metadata">[docs]</a><span class="k">def</span> <span class="nf">_write_parquet_table_with_metadata</span><span class="p">(</span><span class="n">table</span><span class="p">:</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds metadata to parquet output from CytoTable.</span>
<span class="sd">    Note: this mostly wraps pyarrow.parquet.write_table</span>
<span class="sd">    https://arrow.apache.org/docs/python/generated/pyarrow.parquet.write_table.html</span>

<span class="sd">    Args:</span>
<span class="sd">        table: pa.Table:</span>
<span class="sd">            Pyarrow table to be serialized as parquet table.</span>
<span class="sd">        **kwargs: Any:</span>
<span class="sd">            kwargs provided to this function roughly align with</span>
<span class="sd">            pyarrow.parquet.write_table. The following might be</span>
<span class="sd">            examples of what to expect here:</span>
<span class="sd">            - where: str or pyarrow.NativeFile</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">pyarrow</span> <span class="kn">import</span> <span class="n">parquet</span>

    <span class="kn">from</span> <span class="nn">cytotable.constants</span> <span class="kn">import</span> <span class="n">CYTOTABLE_DEFAULT_PARQUET_METADATA</span>
    <span class="kn">from</span> <span class="nn">cytotable.utils</span> <span class="kn">import</span> <span class="n">_get_cytotable_version</span>

    <span class="n">parquet</span><span class="o">.</span><span class="n">write_table</span><span class="p">(</span>
        <span class="n">table</span><span class="o">=</span><span class="n">table</span><span class="o">.</span><span class="n">replace_schema_metadata</span><span class="p">(</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">CYTOTABLE_DEFAULT_PARQUET_METADATA</span>
        <span class="p">),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="_unwrap_value"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._unwrap_value">[docs]</a><span class="k">def</span> <span class="nf">_unwrap_value</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">parsl</span><span class="o">.</span><span class="n">dataflow</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">AppFuture</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to unwrap futures from values or return values</span>
<span class="sd">    where there are no futures.</span>

<span class="sd">    Args:</span>
<span class="sd">        val: Union[parsl.dataflow.futures.AppFuture, Any]</span>
<span class="sd">            A value which may or may not be a Parsl future which</span>
<span class="sd">            needs to be evaluated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Any</span>
<span class="sd">            Returns the value as-is if there&#39;s no future, the future</span>
<span class="sd">            result if Parsl futures are encountered.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if we have a future value, evaluate the result</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">parsl</span><span class="o">.</span><span class="n">dataflow</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">AppFuture</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># if we have a list of futures, return the results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parsl</span><span class="o">.</span><span class="n">dataflow</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">AppFuture</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">elem</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
    <span class="c1"># otherwise return the value</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="_unwrap_source"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._unwrap_source">[docs]</a><span class="k">def</span> <span class="nf">_unwrap_source</span><span class="p">(</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">parsl</span><span class="o">.</span><span class="n">dataflow</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">AppFuture</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">parsl</span><span class="o">.</span><span class="n">dataflow</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">AppFuture</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to unwrap futures from sources.</span>

<span class="sd">    Args:</span>
<span class="sd">        source: Union[</span>
<span class="sd">            Dict[str, Union[parsl.dataflow.futures.AppFuture, Any]],</span>
<span class="sd">            Union[parsl.dataflow.futures.AppFuture, Any],</span>
<span class="sd">        ]</span>
<span class="sd">            A source is a portion of an internal data structure used by</span>
<span class="sd">            CytoTable for processing and organizing data results.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Union[Dict[str, Any], Any]</span>
<span class="sd">            An evaluated dictionary or other value type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if we have a dictionary, unwrap any values which may be futures</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">_unwrap_value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># otherwise try to unwrap the source as-is without dictionary nesting</span>
        <span class="k">return</span> <span class="n">_unwrap_value</span><span class="p">(</span><span class="n">source</span><span class="p">)</span></div>


<div class="viewcode-block" id="evaluate_futures"><a class="viewcode-back" href="../../python-api.html#cytotable.utils.evaluate_futures">[docs]</a><span class="k">def</span> <span class="nf">evaluate_futures</span><span class="p">(</span><span class="n">sources</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates any Parsl futures for use within other tasks.</span>
<span class="sd">    This enables a pattern of Parsl app usage as &quot;tasks&quot; and delayed</span>
<span class="sd">    future result evaluation for concurrency.</span>

<span class="sd">    Args:</span>
<span class="sd">        sources: Union[Dict[str, List[Dict[str, Any]]], str]</span>
<span class="sd">            Sources are an internal data structure used by CytoTable for</span>
<span class="sd">            processing and organizing data results. They may include futures</span>
<span class="sd">            which require asynchronous processing through Parsl, so we</span>
<span class="sd">            process them through this function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[Dict[str, List[Dict[str, Any]]], str]</span>
<span class="sd">            A data structure which includes evaluated futures where they were found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="p">{</span>
            <span class="n">source_group_name</span><span class="p">:</span> <span class="p">[</span>
                <span class="c1"># unwrap sources into future results</span>
                <span class="n">_unwrap_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="n">source_group_vals</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
                    <span class="c1"># if we have a future, return the result</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_group_vals</span><span class="p">,</span> <span class="n">parsl</span><span class="o">.</span><span class="n">dataflow</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">AppFuture</span><span class="p">)</span>
                    <span class="c1"># otherwise return the value</span>
                    <span class="k">else</span> <span class="n">source_group_vals</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">source_group_name</span><span class="p">,</span> <span class="n">source_group_vals</span> <span class="ow">in</span> <span class="n">sources</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="c1"># if we have a dict, use the above, otherwise unwrap the value in case of future</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">_unwrap_value</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="_generate_pagesets"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._generate_pagesets">[docs]</a><span class="k">def</span> <span class="nf">_generate_pagesets</span><span class="p">(</span>
    <span class="n">keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a pageset (keyset pagination) from a list of keys.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        keys List[Union[int, float]]:</span>
<span class="sd">            List of keys to paginate.</span>
<span class="sd">        chunk_size int:</span>
<span class="sd">            Size of each chunk/page.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[Tuple[Union[int, float], Union[int, float]]]:</span>
<span class="sd">            List of (start_key, end_key) tuples representing each page.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize an empty list to store the chunks/pages</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Start index for iteration through the keys</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="c1"># Get the start key for the current chunk</span>
        <span class="n">start_key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Calculate the end index for the current chunk</span>
        <span class="n">end_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Get the end key for the current chunk</span>
        <span class="n">end_key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">end_index</span><span class="p">]</span>

        <span class="c1"># Ensure non-overlapping by incrementing the start of the next range if there are duplicates</span>
        <span class="k">while</span> <span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keys</span><span class="p">[</span><span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">end_key</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Append the current chunk (start_key, end_key) to the list of chunks</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start_key</span><span class="p">,</span> <span class="n">end_key</span><span class="p">))</span>

        <span class="c1"># Update the index to start from the next chunk</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Return the list of chunks/pages</span>
    <span class="k">return</span> <span class="n">chunks</span></div>


<div class="viewcode-block" id="_natural_sort"><a class="viewcode-back" href="../../python-api.html#cytotable.utils._natural_sort">[docs]</a><span class="k">def</span> <span class="nf">_natural_sort</span><span class="p">(</span><span class="n">list_to_sort</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts the given iterable using natural sort adapted from approach</span>
<span class="sd">    provided by the following link:</span>
<span class="sd">    https://stackoverflow.com/a/4836734</span>

<span class="sd">    Args:</span>
<span class="sd">      list_to_sort: List:</span>
<span class="sd">        The list to sort.</span>

<span class="sd">    Returns:</span>
<span class="sd">      List: The sorted list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">re</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">list_to_sort</span><span class="p">,</span>
        <span class="c1"># use a custom key to sort the list</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">key</span><span class="p">:</span> <span class="p">[</span>
            <span class="c1"># use integer of c if it&#39;s a digit, otherwise str</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">else</span> <span class="n">c</span>
            <span class="c1"># Split the key into parts, separating numbers from alphabetic characters</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;([0-9]+)&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="p">],</span>
    <span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CytoTable</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=cytomining&repo=CytoTable&type=star&count=false&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_of_conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python-api.html">Python API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Cytomining Community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>